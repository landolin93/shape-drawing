<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shape Drawing App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        canvas { border: 2px solid #e5e7eb; }
        #accuracy { transition: color 0.3s; }
        .dropdown-menu { display: none; }
        .dropdown:hover .dropdown-menu { display: block; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center">
    <div class="bg-white p-6 rounded-lg shadow-lg max-w-md w-full">
        <h1 class="text-2xl font-bold text-center mb-4">Draw a Shape</h1>
        <div class="flex justify-center space-x-2 mb-4">
            <div class="relative dropdown">
                <button class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Select Shape</button>
                <div class="dropdown-menu absolute bg-white shadow-lg rounded mt-2 z-10">
                    <button onclick="selectShape('circle')" class="block px-4 py-2 text-gray-800 hover:bg-blue-100 w-full text-left">Circle</button>
                    <button onclick="selectShape('triangle')" class="block px-4 py-2 text-gray-800 hover:bg-blue-100 w-full text-left">Triangle</button>
                    <button onclick="selectShape('square')" class="block px-4 py-2 text-gray-800 hover:bg-blue-100 w-full text-left">Square</button>
                    <button onclick="selectShape('star')" class="block px-4 py-2 text-gray-800 hover:bg-blue-100 w-full text-left">Star</button>
                    <button onclick="selectShape('umbrella')" class="block px-4 py-2 text-gray-800 hover:bg-blue-100 w-full text-left">Umbrella</button>
                </div>
            </div>
            <button onclick="toggleSettings()" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">Settings</button>
            <button onclick="resetCanvas()" class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600">Reset</button>
        </div>
        <div id="settings" class="hidden text-center mb-4">
            <label class="inline-flex items-center">
                <input type="checkbox" id="showTemplate" checked class="mr-2">
                <span>Show Template</span>
            </label>
        </div>
        <div class="text-center mb-4">
            <p id="accuracy" class="text-lg font-semibold">Accuracy: 0%</p>
        </div>
        <canvas id="canvas" width="300" height="300" class="mx-auto"></canvas>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const accuracyText = document.getElementById('accuracy');
        const showTemplateCheckbox = document.getElementById('showTemplate');
        const settingsDiv = document.getElementById('settings');
        let isDrawing = false;
        let points = [];
        let selectedShape = null;
        let showTemplate = true;

        // Shape definitions
        const shapeTemplates = {
            circle: generateCirclePoints(150, 150, 100, 100),
            triangle: generateTrianglePoints(150, 150, 100, 100),
            square: generateSquarePoints(150, 150, 100, 100),
            star: generateStarPoints(150, 150, 100, 50, 100),
            umbrella: generateUmbrellaPoints(150, 150, 100, 100)
        };

        function generateCirclePoints(cx, cy, radius, numPoints) {
            const points = [];
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                points.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle)
                });
            }
            return points;
        }

        function generateTrianglePoints(cx, cy, size, numPoints) {
            const points = [];
            const sidePoints = Math.floor(numPoints / 3);
            const vertices = [
                { x: cx, y: cy - size }, // Top
                { x: cx - size, y: cy + size / 2 }, // Bottom left
                { x: cx + size, y: cy + size / 2 } // Bottom right
            ];
            for (let i = 0; i < 3; i++) {
                const start = vertices[i];
                const end = vertices[(i + 1) % 3];
                for (let j = 0; j < sidePoints; j++) {
                    const t = j / sidePoints;
                    points.push({
                        x: start.x + t * (end.x - start.x),
                        y: start.y + t * (end.y - start.y)
                    });
                }
            }
            return points;
        }

        function generateSquarePoints(cx, cy, size, numPoints) {
            const points = [];
            const sidePoints = Math.floor(numPoints / 4);
            const halfSize = size / 2;
            const vertices = [
                { x: cx - halfSize, y: cy - halfSize }, // Top-left
                { x: cx + halfSize, y: cy - halfSize }, // Top-right
                { x: cx + halfSize, y: cy + halfSize }, // Bottom-right
                { x: cx - halfSize, y: cy + halfSize } // Bottom-left
            ];
            for (let i = 0; i < 4; i++) {
                const start = vertices[i];
                const end = vertices[(i + 1) % 4];
                for (let j = 0; j < sidePoints; j++) {
                    const t = j / sidePoints;
                    points.push({
                        x: start.x + t * (end.x - start.x),
                        y: start.y + t * (end.y - start.y)
                    });
                }
            }
            return points;
        }

        function generateStarPoints(cx, cy, outerRadius, innerRadius, numPoints) {
            const points = [];
            const totalPoints = Math.floor(numPoints / 10);
            for (let i = 0; i < totalPoints; i++) {
                const angle = (i / totalPoints) * 2 * Math.PI;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                points.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle)
                });
            }
            return points;
        }

        function generateUmbrellaPoints(cx, cy, size, numPoints) {
            const points = [];
            const canopyPoints = Math.floor(numPoints * 0.6);
            const handlePoints = numPoints - canopyPoints;
            // Semi-circle canopy
            for (let i = 0; i < canopyPoints; i++) {
                const angle = Math.PI * (i / (canopyPoints - 1)) - Math.PI / 2;
                points.push({
                    x: cx + (size * 0.8) * Math.cos(angle),
                    y: cy - (size * 0.5) + (size * 0.5) * Math.sin(angle)
                });
            }
            // Handle
            const handleStart = points[points.length - 1];
            const handleEnd = { x: cx, y: cy + size * 0.8 };
            for (let i = 0; i < handlePoints; i++) {
                const t = i / (handlePoints - 1);
                points.push({
                    x: handleStart.x + t * (handleEnd.x - handleStart.x),
                    y: handleStart.y + t * (handleEnd.y - handleStart.y)
                });
            }
            return points;
        }

        function selectShape(shape) {
            selectedShape = shape;
            resetCanvas();
        }

        function toggleSettings() {
            settingsDiv.classList.toggle('hidden');
        }

        function resetCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            points = [];
            isDrawing = false;
            accuracyText.textContent = 'Accuracy: 0%';
            accuracyText.style.color = 'rgb(255, 0, 0)';
            if (selectedShape && showTemplate) {
                drawTemplate(shapeTemplates[selectedShape]);
            }
        }

        function drawTemplate(templatePoints) {
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.moveTo(templatePoints[0].x, templatePoints[0].y);
            for (let i = 1; i < templatePoints.length; i++) {
                ctx.lineTo(templatePoints[i].x, templatePoints[i].y);
            }
            ctx.closePath();
            ctx.stroke();
        }

        function calculateAccuracy() {
            if (!selectedShape || points.length < 10) return 0;
            const template = shapeTemplates[selectedShape];
            let totalDistance = 0;
            points.forEach(point => {
                let minDistance = Infinity;
                template.forEach(templatePoint => {
                    const distance = Math.sqrt(
                        (point.x - templatePoint.x) ** 2 +
                        (point.y - templatePoint.y) ** 2
                    );
                    minDistance = Math.min(minDistance, distance);
                });
                totalDistance += minDistance;
            });
            const avgDistance = totalDistance / points.length;
            const maxDistance = 100; // Max deviation for 0% accuracy
            const accuracy = Math.max(0, 100 - (avgDistance / maxDistance) * 100);
            return Math.round(accuracy);
        }

        function updateAccuracyDisplay() {
            const accuracy = calculateAccuracy();
            accuracyText.textContent = `Accuracy: ${accuracy}%`;
            const red = Math.round(255 * (1 - accuracy / 100));
            const green = Math.round(255 * (accuracy / 100));
            accuracyText.style.color = `rgb(${red}, ${green}, 0)`;
        }

        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.clientX || (event.touches && event.touches[0].clientX);
            const clientY = event.clientY || (event.touches && event.touches[0].clientY);
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            if (!selectedShape) return;
            isDrawing = true;
            const pos = getMousePos(e);
            points.push(pos);
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const pos = getMousePos(e);
            points.push(pos);
            ctx.lineTo(pos.x, pos.y);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
            updateAccuracyDisplay();
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
            ctx.beginPath();
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!selectedShape) return;
            isDrawing = true;
            const pos = getMousePos(e);
            points.push(pos);
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDrawing) return;
            const pos = getMousePos(e);
            points.push(pos);
            ctx.lineTo(pos.x, pos.y);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
            updateAccuracyDisplay();
        });

        canvas.addEventListener('touchend', () => {
            isDrawing = false;
            ctx.beginPath();
        });

        showTemplateCheckbox.addEventListener('change', () => {
            showTemplate = showTemplateCheckbox.checked;
            resetCanvas();
        });

        // Initial setup
        resetCanvas();
    </script>
</body>
</html>
